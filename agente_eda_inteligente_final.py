# -*- coding: utf-8 -*-
"""Agente_EDA_INTELIGENTE_FINAL.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xSVRVHhxOJXs0ZeNMv_ZukDdjJ97nyot

AGENTE DE IA PARA AN√ÅLISE EXPLORAT√ìRIA DE DADOS

Bem-vindo ao **AGENTE EDA INTELIGENTE**!

**O que este agente pode fazer:**
- **An√°lise de CSV:** Fa√ßa upload de qualquer arquivo CSV para iniciar a an√°lise.
- **Processamento de Linguagem Natural:** Fa√ßa perguntas em portugu√™s e receba insights detalhados gerados pela API Google Gemini.
- **An√°lises Autom√°ticas:** Execute an√°lises de tipos de dados, estat√≠sticas, correla√ß√µes e detec√ß√£o de outliers com um clique.
- **Gera√ß√£o de Gr√°ficos:** Crie e visualize gr√°ficos interativos, que tamb√©m s√£o salvos como imagens.
- **Mem√≥ria e Conclus√µes:** O agente mant√©m um hist√≥rico das an√°lises para gerar conclus√µes abrangentes e permitir o download dos resultados.

**‚ñ∂Ô∏è Como Usar:**
1.  **Configure a API Key:** Siga as instru√ß√µes na C√©lula 2.
2.  **Execute as C√©lulas em Ordem:** A melhor forma √© ir ao menu `Ambiente de execu√ß√£o` e selecionar `Executar tudo`.
3.  **Acesse a Interface:** Ap√≥s a execu√ß√£o, clique no link p√∫blico do Gradio que ser√° gerado no final para abrir o agente.

### **1) INSTALA√á√ÉO DE DEPEND√äNCIAS**
"""

# C√âLULA 1: INSTALA√á√ÉO UNIFICADA DE DEPEND√äNCIAS
!pip install -q google-generativeai gradio pandas numpy matplotlib seaborn plotly scikit-learn openpyxl
!pip install -q -U kaleido
print("‚úÖ Todas as depend√™ncias foram instaladas com sucesso.")

"""### **2) CONFIGURA√á√ÉO DA CHAVE DA API GEMINI**"""

# C√âLULA 2: VERIFICA√á√ÉO DA API KEY NOS SECRETS DO COLAB
from google.colab import userdata

try:
    api_key = userdata.get('GEMINI_API_KEY')
    if api_key and len(api_key) > 20:
        print("‚úÖ API Key configurada corretamente!")
        print(f"üîë Chave encontrada (in√≠cio): {api_key[:10]}...")
        print("üöÄ Pronto para prosseguir!")
    else:
        print("‚ö†Ô∏è API Key muito curta ou inv√°lida.")
        print("üîß Verifique se copiou a chave completa.")
        raise ValueError("API Key inv√°lida.")
except Exception as e:
    print("‚ùå API Key n√£o encontrada!")
    print("üîß Configure GEMINI_API_KEY nos secrets do Colab:")
    print("   1. Clique no √≠cone üîë na barra lateral esquerda.")
    print("   2. Crie um 'new secret' com o nome: GEMINI_API_KEY")
    print("   3. Cole sua chave obtida em: https://makersuite.google.com/app/apikey")
    print("   4. Ative a op√ß√£o 'Acesso ao notebook'.")
    raise ValueError("Configure a API Key antes de continuar!")

"""### **3) C√ìDIGO PRINCIPAL DO AGENTE EDA**"""

# C√âLULA 3: DEFINI√á√ÉO DO AGENTE E DA INTERFACE (VERS√ÉO UNIFICADA E MELHORADA)

# Instala√ß√£o isolada de kaleido dentro desta c√©lula para garantir acesso ao ambiente
!pip install -q -U kaleido
print("‚úÖ Pacote kaleido instalado/atualizado dentro da C√âLULA 3.")


import os
import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import warnings
import uuid
# import plotly.io as pio # N√£o precisamos mais importar pio explicitamente para to_image()
import base64 # Importando base64 para poss√≠vel uso futuro

warnings.filterwarnings('ignore')

import google.generativeai as genai
from google.colab import userdata
import gradio as gr
from typing import Dict, List, Any, Tuple, Optional

# Importa√ß√µes para gera√ß√£o de PDF
from reportlab.lib.pagesizes import letter
from reportlab.pdfgen import canvas
from reportlab.lib.utils import ImageReader
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Image

# Diret√≥rio para salvar gr√°ficos temporariamente (ainda √∫til para outras coisas se necess√°rio)
temp_dir = "temp_plots"
if not os.path.exists(temp_dir):
    os.makedirs(temp_dir)

class CSVAnalysisAgent:
    """Agente de IA especializado em An√°lise Explorat√≥ria de Dados (EDA) para arquivos CSV"""

    def __init__(self, api_key: str):
        genai.configure(api_key=api_key)
        self.model = genai.GenerativeModel('gemini-2.5-flash')
        self.memory: List[Dict[str, Any]] = []
        self.current_data: Optional[pd.DataFrame] = None
        self.data_summary: Optional[Dict[str, Any]] = None
        self.generated_image_bytes: Dict[str, bytes] = {} # Armazenar bytes das imagens geradas (para PDF, se funcionar)
        self.generated_figures: Dict[str, go.Figure] = {} # Armazenar objetos Figure gerados


    def _clear_temp_plots(self):
        """Limpa o diret√≥rio de plots tempor√°rios para evitar ac√∫mulo de arquivos."""
        if os.path.exists(temp_dir):
            for filename in os.listdir(temp_dir):
                file_path = os.path.join(temp_dir, filename)
                try:
                    if os.path.isfile(file_path):
                        os.unlink(file_path)
                except Exception as e:
                    print(f"Falha ao deletar {file_path}. Motivo: {e}")
        self.generated_image_bytes.clear() # Limpar bytes de imagem tamb√©m
        self.generated_figures.clear() # Limpar figuras tamb√©m


    def load_csv_file(self, file_path: str) -> str:
        """Carrega um arquivo CSV para an√°lise e limpa an√°lises anteriores."""
        self._clear_temp_plots() # MELHORIA: Limpa gr√°ficos antigos ao carregar novo arquivo
        self.memory = [] # Reseta a mem√≥ria
        try:
            self.current_data = pd.read_csv(file_path)
            self.data_summary = self._generate_data_summary()
            memory_entry = {
                "action": "load_data",
                "timestamp": pd.Timestamp.now(),
                "data_shape": self.current_data.shape,
                "columns": list(self.current_data.columns)
            }
            self.memory.append(memory_entry)
            return f"Dados carregados com sucesso! Dimens√£o: {self.current_data.shape}"
        except Exception as e:
            self.current_data = None
            self.data_summary = None
            return f"Erro ao carregar arquivo: {str(e)}"

    def _generate_data_summary(self) -> Optional[Dict[str, Any]]:
        if self.current_data is None: return None
        return {
            "shape": self.current_data.shape,
            "columns": list(self.current_data.columns),
            "dtypes": self.current_data.dtypes.astype(str).to_dict(),
            "missing_values": self.current_data.isnull().sum().to_dict(),
            "numeric_columns": list(self.current_data.select_dtypes(include=[np.number]).columns),
            "categorical_columns": list(self.current_data.select_dtypes(include=['object']).columns)
        }

    def analyze_data_types(self) -> Tuple[str, Optional[go.Figure]]:
        if self.current_data is None or self.data_summary is None: return "Nenhum dado carregado.", None
        analysis = {
            "Num√©ricos": len(self.data_summary["numeric_columns"]),
            "Categ√≥ricos": len(self.data_summary["categorical_columns"]),
            "Total de Colunas": len(self.data_summary["columns"])
        }
        fig = px.bar(x=list(analysis.keys()), y=list(analysis.values()), title="Distribui√ß√£o dos Tipos de Dados")
        self.generated_figures['data_types_plot'] = fig # Armazenar figura
        img_bytes = None
        try:
            img_bytes = fig.to_image(format="png") # Gerar bytes da imagem (tentativa para PDF)
            self.generated_image_bytes['data_types_plot'] = img_bytes # Armazenar bytes
            print("‚úÖ Bytes da imagem 'data_types_plot' gerados e armazenados (se kaleido funcionar).")
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao gerar bytes da imagem 'data_types_plot' (kaleido): {e}")

        self.memory.append({"action": "analyze_data_types", "timestamp": pd.Timestamp.now(), "analysis": analysis, "image_key": 'data_types_plot' if img_bytes else None})
        return str(analysis), fig # Retornar apenas texto e figura


    def statistical_summary(self) -> str:
        if self.current_data is None or self.data_summary is None: return "Nenhum dado carregado."
        numeric_stats = self.current_data.describe().to_string()
        categorical_stats = {col: {"valores_unicos": int(self.current_data[col].nunique()), "mais_frequente": str(self.current_data[col].mode().iloc[0])} for col in self.data_summary["categorical_columns"]}
        summary_text = f"Estat√≠sticas Num√©ricas:\n{numeric_stats}\n\nEstat√≠sticas Categ√≥ricas:\n{categorical_stats}"
        self.memory.append({"action": "statistical_summary", "timestamp": pd.Timestamp.now(), "summary": summary_text})
        return summary_text

    def detect_outliers(self, column_name: Optional[str] = None) -> Tuple[str, Optional[go.Figure]]:
        if self.current_data is None or self.data_summary is None: return "Nenhum dado carregado.", None
        numeric_cols = self.data_summary["numeric_columns"]
        cols_to_analyze = [column_name] if (column_name and column_name in numeric_cols) else numeric_cols[:4]
        if not cols_to_analyze: return "N√£o h√° colunas num√©ricas para analisar.", None
        fig = make_subplots(rows=1, cols=len(cols_to_analyze), subplot_titles=cols_to_analyze)
        outliers_info = {}
        for i, col in enumerate(cols_to_analyze):
            series = self.current_data[col].dropna()
            if not series.empty:
                Q1, Q3 = series.quantile(0.25), series.quantile(0.75)
                IQR = Q3 - Q1
                lower, upper = Q1 - 1.5 * IQR, Q3 + 1.5 * IQR
                outliers = self.current_data[(self.current_data[col] < lower) | (self.current_data[col] > upper)]
                outliers_info[col] = {"contagem": len(outliers), "percentual": (len(outliers) / len(self.current_data)) * 100}
                fig.add_trace(go.Box(y=self.current_data[col], name=col), row=1, col=i + 1)
        fig.update_layout(title="Detec√ß√£o de Outliers - Boxplots")
        info_text = f"Informa√ß√£o de Outliers: {outliers_info}"
        self.generated_figures['outliers_plot'] = fig # Armazenar figura
        img_bytes = None
        try:
            img_bytes = fig.to_image(format="png") # Gerar bytes da imagem (tentativa para PDF)
            self.generated_image_bytes['outliers_plot'] = img_bytes # Armazenar bytes
            print("‚úÖ Bytes da imagem 'outliers_plot' gerados e armazenados (se kaleido funcionar).")
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao gerar bytes da imagem 'outliers_plot' (kaleido): {e}")


        self.memory.append({"action": "detect_outliers", "timestamp": pd.Timestamp.now(), "outliers_info": outliers_info, "image_key": 'outliers_plot' if img_bytes else None})
        return info_text, fig # Retornar apenas texto e figura


    def correlation_analysis(self) -> Tuple[str, Optional[go.Figure]]:
        if self.current_data is None: return "Nenhum dado carregado.", None
        numeric_data = self.current_data.select_dtypes(include=[np.number])
        if numeric_data.shape[1] < 2: return "Poucas colunas num√©ricas para correla√ß√£o.", None
        corr_matrix = numeric_data.corr(numeric_only=True)
        fig = px.imshow(corr_matrix, title="Matriz de Correla√ß√£o", color_continuous_scale="RdBu", aspect="auto")
        high_corr = {f"{c1}-{c2}": corr_matrix.loc[c1, c2] for c1 in corr_matrix.columns for c2 in corr_matrix.columns if c1 != c2 and abs(corr_matrix.loc[c1, c2]) > 0.7}
        info_text = f"Correla√ß√µes Altas (abs > 0.7): {high_corr}"
        self.generated_figures['correlation_plot'] = fig # Armazenar figura
        img_bytes = None
        try:
            img_bytes = fig.to_image(format="png") # Gerar bytes da imagem (tentativa para PDF)
            self.generated_image_bytes['correlation_plot'] = img_bytes # Armazenar bytes
            print("‚úÖ Bytes da imagem 'correlation_plot' gerados e armazenados (se kaleido funcionar).")
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao gerar bytes da imagem 'correlation_plot' (kaleido): {e}")

        self.memory.append({"action": "correlation_analysis", "timestamp": pd.Timestamp.now(), "high_correlations": high_corr, "image_key": 'correlation_plot' if img_bytes else None})
        return info_text, fig # Retornar apenas texto e figura

    def save_plots_as_html(self) -> List[str]:
        """Salva os gr√°ficos gerados como arquivos HTML no diret√≥rio tempor√°rio."""
        saved_files = []
        print(f"‚ÑπÔ∏è Tentando salvar {len(self.generated_figures)} figura(s) como HTML individual...") # Depura√ß√£o
        if not self.generated_figures:
            print("‚ö†Ô∏è Nenhuma figura gerada para salvar como HTML.")
            return []

        for key, fig in self.generated_figures.items():
            html_filename = os.path.join(temp_dir, f"{key}.html")
            try:
                fig.write_html(html_filename)
                saved_files.append(html_filename)
                print(f"‚úÖ Figura '{key}' salva como HTML em {html_filename}") # Depura√ß√£o
            except Exception as e:
                print(f"‚ùå Erro ao salvar figura '{key}' como HTML: {e}") # Depura√ß√£o

        print(f"‚úÖ Conclu√≠do o salvamento de gr√°ficos individuais. Total de arquivos salvos: {len(saved_files)}") # Depura√ß√£o
        return saved_files

    def _format_memory(self) -> str:
        if not self.memory: return "Nenhuma an√°lise anterior."
        formatted = []
        for entry in self.memory[-10:]:
            action = entry.get("action", "").replace('_', ' ').title()
            # Referenciar a chave da imagem se existir
            img_info = f" | Imagem Key: {entry['image_key']}" if entry.get('image_key') else ""
            if action == "Query":
                response_snippet = entry['response'][:150] + '...' if len(entry['response']) > 150 else entry['response']
                formatted.append(f"- Pergunta: {entry['question']} -> Resposta: {response_snippet}")
            else:
                formatted.append(f"- An√°lise: {action}{img_info}")
        return "\n".join(formatted)

    def get_conclusions(self) -> str:
        if self.current_data is None or self.data_summary is None: return "Nenhum dado carregado."
        context = f"""Baseado em todas as an√°lises realizadas no dataset (hist√≥rico na mem√≥ria), gere conclus√µes abrangentes. Inclua refer√™ncias aos nomes dos arquivos de imagem dos gr√°ficos gerados, quando relevante (use os 'Image Key's do hist√≥rico se dispon√≠veis).
Hist√≥rico de An√°lises:\n{self._format_memory()}\n\nForne√ßa em portugu√™s, com t√≥picos claros:\n1. Principais insights descobertos.\n2. Padr√µes e tend√™ncias identificados.\n3. Avalia√ß√£o da qualidade dos dados (valores faltantes, outliers).\n4. Recomenda√ß√µes para an√°lises futuras ou a√ß√µes de neg√≥cio."""
        try:
            response = self.model.generate_content(context)
            return response.text if hasattr(response, 'text') and response.text else "O modelo n√£o gerou conclus√µes."
        except Exception as e:
            return f"Erro ao gerar conclus√µes: {str(e)}"

    def generate_pdf_report(self) -> Optional[str]:
        """Gera um relat√≥rio PDF com conclus√µes e gr√°ficos."""
        if self.current_data is None or not self.memory: return None

        pdf_filename = "relatorio_eda.pdf"
        doc = SimpleDocTemplate(pdf_filename, pagesize=letter)
        styles = getSampleStyleSheet()
        story = []

        # Adicionar T√≠tulo
        story.append(Paragraph("Relat√≥rio de An√°lise Explorat√≥ria de Dados (EDA)", styles['h1']))
        story.append(Spacer(1, 12))

        # Adicionar Conclus√µes
        conclusions = self.get_conclusions()
        if conclusions and conclusions != "Nenhum dado carregado." and not conclusions.startswith("Erro ao gerar conclus√µes:"):
            story.append(Paragraph("Conclus√µes e Insights:", styles['h2']))
            # Quebrar o texto das conclus√µes em par√°grafos para ReportLab
            for line in conclusions.split('\n'):
                if line.strip(): # Ignorar linhas vazias
                    story.append(Paragraph(line, styles['Normal']))
                story.append(Spacer(1, 6)) # Espa√ßo entre as linhas/par√°grafos
            story.append(Spacer(1, 12))

        # Adicionar Gr√°ficos (se dispon√≠veis em bytes)
        # Mantendo a tentativa de adicionar imagens, mas lidando com a falha
        if self.generated_image_bytes and any(self.generated_image_bytes.values()): # Verifica se h√° *algum* byte de imagem gerado
            story.append(Paragraph("Gr√°ficos Gerados:", styles['h2']))
            story.append(Spacer(1, 12))
            print(f"‚ÑπÔ∏è Tentando adicionar {len([b for b in self.generated_image_bytes.values() if b is not None])} imagem(ns) ao PDF...") # Depura√ß√£o: contar apenas imagens com bytes
            for key, img_bytes in self.generated_image_bytes.items():
                if img_bytes: # Verificar se os bytes existem
                    try:
                        print(f"‚û°Ô∏è Adicionando imagem '{key}' ao PDF...") # Depura√ß√£o
                        # Criar ImageReader a partir dos bytes
                        img_reader = ImageReader(img_bytes)
                        img = Image(img_reader)

                        # Redimensionar a imagem para caber na p√°gina, mantendo a propor√ß√£o
                        img_width, img_height = img.drawWidth, img.drawHeight
                        page_width, page_height = letter
                        max_width = page_width - 2 * doc.leftMargin
                        max_height = page_height - 2 * doc.bottomMargin

                        aspect = img_height / float(img_width)
                        if img_width > max_width:
                            img_width = max_width
                            img_height = img_width * aspect
                        if img_height > max_height:
                             img_height = max_height
                             img_width = img_height / aspect

                        img.drawWidth = img_width
                        img.drawHeight = img_height

                        story.append(Paragraph(key.replace('_', ' ').title(), styles['h3']))
                        story.append(Spacer(1, 6))
                        story.append(img)
                        story.append(Spacer(1, 12)) # Espa√ßo ap√≥s o gr√°fico
                        print(f"‚úÖ Imagem '{key}' adicionada com sucesso ao story.") # Depura√ß√£o

                    except Exception as e:
                        print(f"‚ùå Erro ao adicionar imagem '{key}' ao PDF: {e}") # Depura√ß√£o
                        story.append(Paragraph(f"Erro ao carregar ou adicionar imagem '{key}'.", styles['Normal']))
                        story.append(Spacer(1, 6))
                else:
                     print(f"‚è≠Ô∏è Pulando imagem '{key}': Bytes n√£o foram gerados (erro na exporta√ß√£o).") # Depura√ß√£o
                     # Adicionar uma nota no PDF para cada imagem que falhou
                     story.append(Paragraph(f"Imagem '{key}' n√£o gerada (erro na exporta√ß√£o).", styles['Normal']))
                     story.append(Spacer(1, 6))

        elif self.current_data is not None: # Adicionar nota se n√£o houver *nenhuma* imagem gerada mas dados existirem
             story.append(Paragraph("Gr√°ficos Gerados:", styles['h2']))
             story.append(Spacer(1, 12))
             story.append(Paragraph("N√£o foi poss√≠vel incluir os gr√°ficos no relat√≥rio PDF devido a problemas t√©cnicos na exporta√ß√£o de imagens.", styles['Normal']))
             story.append(Spacer(1, 12))


        try:
            doc.build(story)
            print(f"‚úÖ Relat√≥rio PDF '{pdf_filename}' gerado com sucesso.")
            return pdf_filename
        except Exception as e:
            print(f"‚ùå Erro ao construir o PDF: {e}")
            return None

    def generate_html_report(self) -> Optional[str]:
        """Generates an HTML report with conclusions and embedded graphs."""
        if self.current_data is None or not self.memory:
            print("‚ö†Ô∏è Nenhum dado carregado ou nenhuma an√°lise na mem√≥ria para gerar relat√≥rio HTML.") # Depura√ß√£o
            return None

        html_filename = os.path.join(temp_dir, "relatorio_eda.html")
        conclusions = self.get_conclusions()

        # Gerar HTML para os gr√°ficos
        chart_html = ""
        print(f"‚ÑπÔ∏è Verificando figuras geradas para incluir no HTML: {len(self.generated_figures)}") # Depura√ß√£o
        if self.generated_figures:

            for key, fig in self.generated_figures.items():
                try:
                    print(f"‚û°Ô∏è Convertendo gr√°fico '{key}' para HTML...") # Depura√ß√£o
                    # Converter figura Plotly para HTML
                    fig_html = fig.to_html(full_html=False, include_plotlyjs='cdn') # Usar CDN para plotly.js
                    chart_html += f"""
                    <div class="graph">
                        <h3>{key.replace('_', ' ').title()}</h3>
                        {fig_html}
                    </div>
                    """
                    print(f"‚úÖ Gr√°fico '{key}' convertido para HTML e inclu√≠do.") # Depura√ß√£o
                except Exception as e:
                    print(f"‚ùå Erro ao converter gr√°fico '{key}' para HTML: {e}") # Depura√ß√£o
                    chart_html += f"""
                    <div class="graph">
                        <h3>{key.replace('_', ' ').title()}</h3>
                        <p>N√£o foi poss√≠vel renderizar o gr√°fico '{key}'.</p>
                    </div>
                    """
        else:
             print("‚ö†Ô∏è Nenhuma figura gerada para incluir no relat√≥rio HTML.") # Depura√ß√£o
             chart_html = "<p>Nenhum gr√°fico gerado para incluir neste relat√≥rio.</p>"


        html_content = """
<!DOCTYPE html>
<html>
<head>
    <title>Relat√≥rio de An√°lise Explorat√≥ria de Dados (EDA)</title>
    <meta charset="utf-8"> <!-- Garantir codifica√ß√£o UTF-8 -->
    <style>
        body {{ font-family: sans-serif; margin: 20px; }}
        h1, h2, h3 {{ color: #333; }}
        .section {{ margin-bottom: 20px; padding-bottom: 10px; border-bottom: 1px solid #eee; }}
        .graph {{ margin-top: 15px; text-align: center; }}
        /* Remover regras de imagem est√°tica */
        /* .graph img {{ max-width: 100%; height: auto; }} */
    </style>
</head>
<body>
    <h1>Relat√≥rio de An√°lise Explorat√≥ria de Dados (EDA)</h1>
    <div class="section">
        <h2>Conclus√µes e Insights</h2>
        {}
    </div>
    <div class="section">
        <h2>Gr√°ficos Gerados</h2>
        {}
    </div>
</body>
</html>
""".format(
            # Format conclusions
            "".join(f"<p>{line}</p>" for line in conclusions.split('\n') if line.strip()) if conclusions and conclusions != "Nenhum dado carregado." and not conclusions.startswith("Erro ao gerar conclus√µes:") else "<p>Nenhuma conclus√£o gerada.</p>",
            # Format charts as HTML
            chart_html
        )

        try:
            with open(html_filename, "w", encoding="utf-8") as f:
                f.write(html_content)
            print(f"‚úÖ Relat√≥rio HTML '{html_filename}' gerado com sucesso.") # Depura√ß√£o
            return html_filename
        except Exception as e:
            print(f"‚ùå Erro ao gerar relat√≥rio HTML: {e}") # Depura√ß√£o
            return None


def create_gradio_interface():
    """Cria e configura a interface Gradio para o agente EDA."""
    agent: Optional[CSVAnalysisAgent] = None
    latest_conclusions: str = ""
    # generated_images: List[str] = [] # N√£o precisamos mais da lista de caminhos de arquivo

    # Mover as fun√ß√µes handlers para o topo para garantir que estejam definidas antes de serem usadas
    def initialize_agent() -> str:
        nonlocal agent
        try:
            api_key = userdata.get('GEMINI_API_KEY')
            agent = CSVAnalysisAgent(api_key=api_key)
            return "‚úÖ Agente inicializado com sucesso! Pronto para carregar dados."
        except Exception as e:
            return f"‚ùå Erro ao inicializar agente: {e}. Verifique a API Key."

    # Removido generated_images do retorno, pois n√£o listamos mais arquivos
    def load_file(file: gr.File) -> str:
        nonlocal agent # generated_images
        if agent is None: return "‚ùå Inicialize o agente primeiro!" # , []
        if file is None: return "‚ö†Ô∏è Nenhum arquivo selecionado." # , []
        # generated_images.clear() # N√£o precisamos mais limpar a lista de caminhos de arquivo
        status = agent.load_csv_file(file.name)
        return status # , []

    # Simplificado o retorno para apenas texto e figura
    def update_images_list(analysis_text, fig): # Removido img_path
        # nonlocal generated_images # N√£o precisamos mais desta lista para exibi√ß√£o
        # if img_path and os.path.exists(img_path):
        #     generated_images.append(img_path)
        return analysis_text, fig

    # Fun√ß√µes handlers para os bot√µes de an√°lise que retornam texto e figura
    def get_data_types_interface():
        if agent is None: return "‚ùå Inicialize o agente primeiro!", None
        analysis_text, fig = agent.analyze_data_types()
        return update_images_list(analysis_text, fig)

    def detect_outliers_interface():
        if agent is None: return "‚ùå Inicialize o agente primeiro!", None
        analysis_text, fig = agent.detect_outliers()
        return update_images_list(analysis_text, fig)

    def correlation_analysis_interface():
        if agent is None: return "‚ùå Inicialize o agente primeiro!", None
        analysis_text, fig = agent.correlation_analysis()
        return update_images_list(analysis_text, fig)

    # Fun√ß√£o handler para gerar e baixar o PDF
    def generate_and_download_pdf_interface() -> Optional[str]:
        nonlocal agent
        if agent is None: return None
        pdf_path = agent.generate_pdf_report()
        return pdf_path

    # Fun√ß√£o handler para gerar e retornar o arquivo HTML de relat√≥rio completo
    def generate_and_download_html_report_interface() -> Optional[str]:
        nonlocal agent
        if agent is None: return None
        html_path = agent.generate_html_report()
        return html_path

    # Fun√ß√£o handler para salvar gr√°ficos individuais como HTML
    def save_plots_as_html_interface() -> gr.File | None: # Retorno pode ser None
        nonlocal agent
        if agent is None: return None
        saved_files = agent.save_plots_as_html()
        if saved_files:
            # Retorna o primeiro arquivo para download
            # Como o usu√°rio relatou ver apenas 1 arquivo, talvez retornar todos como lista?
            # Gradio File component pode aceitar lista para download zipado.
            # Vamos tentar retornar a lista completa.
            return gr.File(value=saved_files, visible=True, label="Download Gr√°ficos HTML Individuais")
        else:
            return None # Retorna None se nenhum arquivo foi salvo


    def get_conclusions_interface() -> str:
        nonlocal agent, latest_conclusions
        if agent is None: return "‚ùå Inicialize o agente primeiro!"
        latest_conclusions = agent.get_conclusions()
        return latest_conclusions

    # Removida a fun√ß√£o de download de conclus√µes em TXT
    # def download_conclusions() -> Optional[str]:
    #     nonlocal latest_conclusions
    #     if not latest_conclusions: return None
    #     file_path = "conclusoes_eda.txt"
    #     with open(file_path, "w", encoding="utf-8") as f:
    #         f.write(latest_conclusions)
    #     return file_path

    # Esta fun√ß√£o n√£o √© mais necess√°ria ou funcional da mesma forma
    # Mantida como placeholder ou removida dependendo da necessidade futura de listar *algo*
    def list_generated_images_interface():
         # nonlocal generated_images # N√£o precisamos mais desta lista para exibi√ß√£o
         # return [gr.File(value=path, visible=True) for path in generated_images]
         # Poderia listar as chaves das imagens em mem√≥ria, mas a galeria espera caminhos de arquivo ou URIs de imagem
         return [] # Retorna lista vazia j√° que n√£o estamos salvando arquivos de imagem


    with gr.Blocks(title="Agente EDA", theme=gr.themes.Soft()) as interface:
        gr.Markdown("# ü§ñ Agente Inteligente para An√°lise Explorat√≥ria de Dados (EDA)")
        with gr.Row():
            with gr.Column():
                init_btn = gr.Button("üöÄ Inicializar Agente", variant="primary")
                init_output = gr.Textbox(label="Status da Inicializa√ß√£o", interactive=False)
                file_input = gr.File(label="üìÅ Upload do arquivo CSV", file_types=[".csv"])
                load_output = gr.Textbox(label="Status do Carregamento", interactive=False)

        with gr.Tabs():
            with gr.TabItem("üìä An√°lises Autom√°ticas"):
                with gr.Row():
                    types_btn = gr.Button("üîç Tipos de Dados")
                    stats_btn = gr.Button("üìà Resumo Estat√≠stico")
                    outliers_btn = gr.Button("‚ö†Ô∏è Detectar Outliers")
                    corr_btn = gr.Button("üîó Correla√ß√£o")
                analysis_output = gr.Textbox(label="Resultado da An√°lise", lines=8, interactive=False)
                analysis_plot = gr.Plot(label="Visualiza√ß√£o da An√°lise")

            with gr.TabItem("üéØ Conclus√µes e Download"):
                conclusions_btn = gr.Button("üß† Gerar Conclus√µes Finais", variant="secondary")
                conclusions_output = gr.Textbox(label="Conclus√µes e Insights", lines=15, interactive=False)
                with gr.Row():
                    # Removido o bot√£o e componente de download TXT
                    # download_txt_btn = gr.Button("üíæ Baixar Conclus√µes (.txt)") # Renomeado para clareza
                    # download_txt_file_output = gr.File(label="Arquivo de Conclus√µes (.txt)", interactive=False) # Renomeado
                    pass # Usado para manter a estrutura da linha sem o componente removido

                gr.Markdown("### Relat√≥rio Completo (PDF):")
                with gr.Row():
                     generate_pdf_btn = gr.Button("üìÑ Gerar Relat√≥rio PDF", variant="secondary") # Novo bot√£o
                     download_pdf_file_output = gr.File(label="Relat√≥rio EDA (.pdf)", interactive=False) # Novo componente de download de PDF

                gr.Markdown("### Relat√≥rio Completo (HTML):")
                with gr.Row():
                    generate_html_report_btn = gr.Button("üìÑ Gerar Relat√≥rio HTML", variant="secondary") # Novo bot√£o
                    download_html_report_output = gr.File(label="Relat√≥rio EDA (.html)", interactive=False) # Novo componente de download

                gr.Markdown("### Salvar Gr√°ficos Individuais (HTML):")
                with gr.Row():
                    save_html_btn = gr.Button("üíæ Salvar Gr√°ficos Individuais como HTML") # Novo bot√£o para salvar HTML individual
                    # Alterado para tentar retornar a lista completa de arquivos para download zipado pelo Gradio
                    download_individual_html_output = gr.File(label="Download Gr√°ficos HTML Individuais (Zip)", interactive=False, visible=False) # Componente para download individual


                gr.Markdown("### Imagens Geradas: (Exibidas na aba 'An√°lises Autom√°ticas'. Download ou listagem de arquivos est√°ticos n√£o dispon√≠vel.)")
                # Ocultar ou remover componentes de listagem/download de imagens de arquivo
                # refresh_images_btn = gr.Button("üîÑ Atualizar Lista de Imagens") # Ocultar ou remover
                # image_files_gallery = gr.Gallery(label="Imagens Geradas", show_label=False, columns=4, object_fit="contain", visible=False) # Ocultar ou remover

        # Event Handlers
        init_btn.click(fn=initialize_agent, outputs=init_output)
        # Removido image_files_gallery do output
        file_input.change(fn=load_file, inputs=file_input, outputs=[load_output])
        stats_btn.click(fn=lambda: agent.statistical_summary() if agent else "Inicialize o agente.", outputs=analysis_output)
        # Removido image_files_gallery do output
        types_btn.click(fn=get_data_types_interface, outputs=[analysis_output, analysis_plot])
        outliers_btn.click(fn=detect_outliers_interface, outputs=[analysis_output, analysis_plot])
        corr_btn.click(fn=correlation_analysis_interface, outputs=[analysis_output, analysis_plot])
        conclusions_btn.click(fn=get_conclusions_interface, outputs=conclusions_output)
        # Removido handler download TXT
        # download_txt_btn.click(fn=download_conclusions, outputs=download_txt_file_output)
        # Handler para gerar e baixar o PDF
        generate_pdf_btn.click(fn=generate_and_download_pdf_interface, outputs=download_pdf_file_output) # Usando a nova fun√ß√£o handler
        # Handler para gerar e baixar o relat√≥rio HTML completo
        generate_html_report_btn.click(fn=generate_and_download_html_report_interface, outputs=download_html_report_output) # Usando a nova fun√ß√£o handler
        # Handler para salvar gr√°ficos individuais como HTML
        save_html_btn.click(fn=save_plots_as_html_interface, outputs=download_individual_html_output)

        # Removido handler e componentes de listagem/download de imagens de arquivo
        # refresh_images_btn.click(fn=fn=list_generated_images_interface, outputs=image_files_gallery) # Removido o handler e mantido a fun√ß√£o vazia


    return interface

"""### **4) INICIALIZA√á√ÉO DA INTERFACE GRADIO**"""

# C√âLULA 4: INICIALIZAR E EXECUTAR A APLICA√á√ÉO
import asyncio
import platform

# Tentar resolver problemas de loop de evento em alguns ambientes
# Verifica se o sistema operacional √© Windows antes de usar a pol√≠tica de loop padr√£o
# if platform.system() == 'Windows':
#     asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())

# For√ßar um novo loop de evento para evitar conflitos (√∫til em Colab/Jupyter)
try:
    loop = asyncio.get_running_loop()
except RuntimeError: # No running loop
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)


print("üöÄ Iniciando o Agente EDA...")
print("‚è≥ Aguarde a interface Gradio carregar e clique no link p√∫blico abaixo para abrir o agente.")

try:
    interface = create_gradio_interface()
    interface.launch(
        share=True,        # Gera link p√∫blico
        debug=True,        # Modo debug para ver logs de erro
        show_error=True    # Mostra erros na interface
    )
except Exception as e:
    print(f"‚ùå Falha ao iniciar a interface Gradio: {str(e)}")
    print("üîß Verifique as mensagens de erro acima. Tente reiniciar o ambiente de execu√ß√£o.")

"""---
### üìö Recursos Adicionais

"""

# C√âLULA 5 (Opcional): LISTAR MODELOS DISPON√çVEIS
import google.generativeai as genai
from google.colab import userdata

try:
    api_key = userdata.get('GEMINI_API_KEY')
    genai.configure(api_key=api_key)
    print("Listando modelos dispon√≠veis que suportam 'generateContent':")
    for m in genai.list_models():
        if 'generateContent' in m.supported_generation_methods:
            print(m.name)
except Exception as e:
    print(f"Erro ao listar modelos: {e}")

"""* * *
### üìö Adicionais e Diagn√≥sticos

*   **Reposit√≥rio GitHub do Agente EDA Inteligente:** Acesse o c√≥digo-fonte e mais informa√ß√µes sobre o agente em https://github.com/MarisaDeM/EDA_INTELIGENTE
"""